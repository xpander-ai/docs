---
title: "Tools & Connectors"
description: "Add capabilities to your agents using Tools (APIs as function calling) and MCP servers"
icon: "plug"
---

xpander provides two ways to add capabilities to your agents:

<CardGroup cols={2}>
<Card title="Tools" icon="wrench">
APIs exposed as function calling with advanced filtering, authentication, and Agentic RAG
</Card>

<Card title="MCP Servers" icon="server">
Connect to Model Context Protocol servers for standardized tool integration
</Card>
</CardGroup>

## Tools

Tools are APIs that xpander exposes to your agents as function calling capabilities. Your agent can invoke these functions during conversations to access external data and services.

### Pre-built Tools Library

Browse and select from hundreds of pre-built tools in the Workbench, covering popular SaaS platforms like GitHub, Google Workspace, Jira, Asana, Notion, and more.

<CardGroup cols={3}>
<Card title="Ready to Use" icon="play">
No configuration required, just select and enable
</Card>

<Card title="Production-tested" icon="shield-check">
Built and maintained by the xpander connector generator agent
</Card>

<Card title="Regularly Updated" icon="arrow-rotate-right">
Keep pace with API changes and new features
</Card>
</CardGroup>

<Note>
You can also generate your own tools by providing an OpenAPI/Swagger specification. This allows you to create private tools for your internal APIs or custom home-grown services.
</Note>

### Custom Tools with SDK

Register your own functions directly in your agent's code using the `@register_tool` decorator for complete control over tool behavior and integration.

<CodeGroup>

```python Custom Tools
from xpander_sdk import Backend, register_tool
from agno.agent import Agent

@register_tool
def weather_check(location: str) -> str:
    """Check weather for a location"""
    return f"Weather in {location}: Sunny, 25°C"

backend = Backend()
agno_agent = Agent(**backend.get_args())
agno_agent.print_response(message="What's the weather in SFO?")
```

```python Pre-built Tools
from xpander_sdk import Backend
from agno.agent import Agent

backend = Backend()
agno_agent = Agent(**backend.get_args())
agno_agent.print_response(message="Check my calendar")
```
</CodeGroup>

The agent has access to both pre-built tools (configured in the Workbench) and your custom tools. The `agno_agent.tools` property contains all available functions, seamlessly combining cloud-managed tools with your local custom tools.

### Advanced Tool Capabilities

Each tool in the Workbench can be configured with powerful optimization features. Click the Settings button next to any tool to access:

<CardGroup cols={3}>
<Card title="Scheme Editor" icon="sliders">
Edit input and output schemas to customize tool behavior
</Card>

<Card title="Agentic RAG" icon="filter">
Semantic querying for large payloads before loading into memory
</Card>

<Card title="Filtering & PII" icon="shield">
Cherry-pick fields and remove sensitive data
</Card>
</CardGroup>

**Key capabilities:**
- **Input Schema** - Hard-code parameters, set defaults, or restrict what the agent can control
- **Output Schema** - Filter response fields, remove PII, reduce token usage
- **Agentic RAG** - When APIs return large datasets (1M records), agents can semantically query and retrieve only relevant items before loading into memory

See the [Tool Scheme Advanced Tab](#tool-scheme-advanced-tab) section below for detailed configuration options.

## Authentication

### Authentication Methods

<CardGroup cols={3}>
<Card title='API Keys' icon='key'>
Token-based authentication
</Card>

<Card title='OAuth 2.0' icon='shield-check'>
Delegated access with user consent
</Card>

<Card title='AWS IAM Roles' icon='aws'>
Temporary cross-account credentials
</Card>
</CardGroup>

### Authentication Modes

- **Integration User** - Shared credentials for all agents
- **End-User** - Individual user authentication (Slack agents only)
- **No Authentication** - For public connectors

### API Key Authentication

#### Configuration

1. Go to **Connectors** → select your connector
2. Click **Other auth options**
3. Enter a connector name
4. Select **Integration User** mode
5. Choose **API Key** method
6. Enter your API key
7. Select Auth Type:
   - **Bearer** - `Authorization: Bearer {token}`
   - **Basic** - Base64 encoded credentials
   - **Custom** - Define your own header
8. Save

<Frame>
![API Key Configuration](/images/connectors/github-issues-manager/img_3.png)
</Frame>

### OAuth 2.0 Authentication

#### Built-in OAuth (Recommended)

1. Go to **Connectors** → select your connector
2. Click **Sign in with {Service}**
3. Grant permissions
4. Done

xpander manages tokens and handles refresh automatically.

<Frame>
![OAuth Flow](/images/oauth.png)
</Frame>

### AWS Cross-Account IAM Roles

Use IAM roles to grant xpander temporary access to AWS services (S3, CloudWatch, Lambda, etc.) without sharing long-term credentials.

#### Setup (CLI)

Replace `<YOUR_ACCOUNT_ID>` with your AWS account ID:

##### 1. Create the Trust Policy

```bash
cat > trust-policy.json <<'EOF'
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::211125312782:role/api-caller-sa"
      },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "cca29b9b-f718-43a3-8802-84e812a019e1"
        }
      }
    }
  ]
}
EOF
```

<Note>
The external ID prevents the [confused deputy problem](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html). Always use this exact value.
</Note>

##### 2. Create the IAM Role

```bash
aws iam create-role \
  --role-name xpanderAccessRole \
  --assume-role-policy-document file://trust-policy.json \
  --description "Grants xpander cross-account access to AWS services"
```

##### 3. Add Permissions

```bash
cat > xpander-access-policy.json <<'EOF'
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:ListBucket",
        "cloudwatch:GetMetricStatistics",
        "lambda:GetFunction",
        "logs:GetLogEvents"
      ],
      "Resource": "*"
    }
  ]
}
EOF

aws iam put-role-policy \
  --role-name xpanderAccessRole \
  --policy-name xpanderAccessPolicy \
  --policy-document file://xpander-access-policy.json
```

<Warning>
In production, restrict `Resource` to specific ARNs: `"Resource": ["arn:aws:s3:::my-bucket/*"]`
</Warning>

##### 4. Get Role ARN

```bash
aws iam get-role --role-name xpanderAccessRole --query "Role.Arn" --output text
```

Output: `arn:aws:iam::<YOUR_ACCOUNT_ID>:role/xpanderAccessRole`

##### 5. Connect in xpander

1. Go to **Connections** → **Add new** → **AWS**
2. Choose **Assume Role**
3. Paste Role ARN
4. Save

<Frame>
![AWS IAM Role Configuration](/images/aws-iam-config.png)
</Frame>

#### Common Permission Policies

<AccordionGroup>

<Accordion title="S3">

```json
{
  "Effect": "Allow",
  "Action": ["s3:GetObject", "s3:PutObject", "s3:ListBucket"],
  "Resource": ["arn:aws:s3:::my-bucket", "arn:aws:s3:::my-bucket/*"]
}
```

</Accordion>

<Accordion title="CloudWatch Logs">

```json
{
  "Effect": "Allow",
  "Action": ["logs:DescribeLogGroups", "logs:GetLogEvents"],
  "Resource": "arn:aws:logs:*:*:log-group:/aws/*"
}
```

</Accordion>

<Accordion title="Lambda">

```json
{
  "Effect": "Allow",
  "Action": ["lambda:InvokeFunction", "lambda:GetFunction"],
  "Resource": "arn:aws:lambda:*:*:function:*"
}
```

</Accordion>

</AccordionGroup>

## MCP (Model Context Protocol)

In addition to Tools, you can connect your agents to MCP servers to provide additional capabilities. MCP servers are a standardized way to expose tools and resources using the [Model Context Protocol](https://modelcontextprotocol.io).

<CardGroup cols={2}>
<Card title="Remote MCPs" icon="cloud">
Connect to MCP servers hosted externally - in your infrastructure or by SaaS providers
</Card>

<Card title="Local MCPs" icon="server">
Run MCP servers directly alongside your agent in the xpander cloud environment
</Card>
</CardGroup>

### Remote MCPs

Use remote MCPs to connect your agent to an MCP server hosted externally.

**How it works:**
1. Provide a URL to a running MCP server
2. Select which tools from the MCP server to attach to your agent
3. xpander connects to it at runtime and makes the tools available to your agent

### Local MCPs

Use local MCPs to run an MCP server process directly alongside your agent.

**How it works:**
1. Define the command that runs the MCP server process
2. xpander launches it as part of the agent's lifecycle
3. The server runs in the xpander cloud environment
4. Tools from the MCP server are automatically available to your agent

<Note>
To create and manage MCP servers, compose tools from multiple connectors, or use agents as MCP servers, see the [MCP Task Source](/user-guide/task-sources/mcp) documentation.
</Note>

## Tool Dependencies

Tool dependencies control the execution order of your agent's tools. When you set a dependency, Tool B will only run after Tool A completes successfully, while Tool A can still run independently. This is useful for workflows where one tool needs data from another or if you want to make sure a tool never runs before a different tool is invoked.

**How to set dependencies:**
1. Click the top connection point of the tool that must wait (Tool B)
2. Drag the line to the bottom connection point of the tool it depends on (Tool A)
3. The dependency will be created automatically

You can add multiple dependencies to a single tool, creating complex workflow chains.

In the following example, we set the `Send Email` tool to only be available after the Calendly `Get Availability Schedule` tool is called.

<Frame>
![alt text](/images/tool_dep.png)
</Frame>



## Tool Scheme Advanced Tab

Individual tool details and configurations are available in the Workbench by clicking the Settings button next to each tool.

<Tabs>
  <Tab title="Details">
    The Details tab shows the original, generated function calling description that defines the tool's purpose and behavior. This serves as a reference for the tool's intended use.
    
    <Frame>
    ![Tool Details Tab](/static/images/screenshots/2025-03-15-22-57-40.png)
    </Frame>
    
    This information is especially useful when you're working with multiple similar tools and need to understand the exact purpose of each one.
  </Tab>
  
  <Tab title="Instructions">
    The Instructions tab allows you to add custom descriptions to provide more context about the tool. This is particularly useful for:
    
    - Giving the AI agent specific guidance on when to use this tool
    - Explaining nuances about the data returned by the tool
    - Setting expectations about rate limits or performance considerations
    - Providing examples of effective usage patterns

    <Frame>
    ![Tool Instructions Tab](/static/images/screenshots/2025-03-15-22-58-05.png)
    </Frame>
    
    <Tip>
    Well-crafted instructions can significantly improve your agent's decision-making when choosing and using tools. Be specific about when the tool should and shouldn't be used.
    </Tip>
  </Tab>
  
  <Tab title="Input Schema">
    The Input Schema tab lets you hard-code parameters to override values that would normally be generated by the AI model during tool calling. This gives you precise control over tool execution, which is useful for:
    
    - Enforcing specific parameter values regardless of the AI model decisions
    - Setting default values that the AI can override when needed
    - Restricting certain parameters to prevent undesired behaviors
    - Pre-configuring complex parameters that require specific formatting
    
    <Frame>
    ![Parameter Override Settings](/static/images/screenshots/2025-03-15-22-58-36.png)
    </Frame>
    
    <Accordion title="Example: Hard-coding API Keys">
    If your tool requires an API key or authentication token, you can hard-code it in the Input Schema rather than having the AI provide it:
    
    1. Find the parameter that requires the API key (often called `apiKey` or `authToken`)
    2. Click the parameter and enter your key as the default value
    3. Mark it as "Use Default Value" to ensure the AI cannot override it
    
    This keeps sensitive credentials secure while allowing the AI to control other parameters.
    </Accordion>
  </Tab>
  
  <Tab title="Output Schema">
    The Output Schema tab lets you configure filtering that runs before payload data is returned to the AI model. This is extremely valuable for:
    
    - Reducing token usage by removing unnecessary data
    - Removing personally identifiable information (PII)
    - Focusing the AI model on the most relevant parts of the response
    - Preventing the AI model from seeing sensitive or irrelevant data

    <Frame>
    ![Output Schema Filtering](/static/images/screenshots/2025-03-15-22-59-03.png)
    </Frame>
    
    <Accordion title="How Output Filtering Works">
    When you configure the Output Schema, you're essentially creating a template that determines which fields from the API response will be passed to the AI model:
    
    1. Expand the schema tree to see all available fields
    2. Toggle fields on/off to include/exclude them from the AI model's view
    3. For nested data structures, you can selectively include specific sub-fields
    
    For example, if a LinkedIn profile response contains personal contact information you don't want the AI model to access, you can exclude those specific fields while keeping professional details visible.
    </Accordion>
  </Tab>
  
  <Tab title="Advanced (Agentic RAG)">

    The Advanced tab enables **Agentic RAG for Large Payloads** - a powerful feature that allows your agent to semantically query large API responses before loading data into memory.

    <Frame>
    ![Advanced Filtering Options](/static/images/screenshots/2025-03-15-22-59-29.png)
    </Frame>

    **How it works:**
    1. Backend API returns large payload (e.g., 1M user records, thousands of log entries)
    2. Agent provides a semantic query at runtime (e.g., "users in engineering department", "errors from last hour")
    3. xpander filters the payload using semantic search
    4. Only relevant items are loaded into agent memory

    This is especially useful when working with:
    - Large datasets with hundreds or thousands of records
    - APIs that return verbose responses with many fields
    - Data that requires complex filtering logic

    The agent can specify search criteria at runtime, and only matching results will be returned, dramatically reducing token usage and improving response quality.
  </Tab>
</Tabs>
